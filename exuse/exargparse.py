import logging
from typing import Callable, List
from argparse import ArgumentParser, HelpFormatter, Namespace


class BaseHandler(object):
    """
    If program has an `action` argument to handle different transactions, you 
    can realize these actions in the subclass of `BaseHandler`. Each action 
    can be defined as a static method using `@staticmethod` decorator. The 
    static method has only one parameter named `args` which is generated by 
    argument parsers, so that `action` method can access the arguments provided
    by command line. Call `set_default` or other methods of the arugment parser
    to bind the custom handler.
    """

    @classmethod
    def run(cls, args):
        return getattr(cls, args.action)(args)


class SmartFormatter(HelpFormatter):
    """
    Set help message by a multi-line string quoting by `\"\"\"` or `'''`).
    """

    def _split_lines(self, text: str, width: int) -> List[str]:
        # return [*[s.strip(' \n') for s in text.strip(' \n').split('\n')], '']
        return [s.strip(' \n') for s in text.strip(' \n').split('\n')]


class ExArgumentParser(ArgumentParser):
    """
    Extend the default `ArgumentParser`. Main contents appended:
    - set our custom `SmartFormatter` as the default formatter class
    - provide `get_subparser` method to get a subparser quickly
    - provide `set_callback` method to set callback function or Callback class
      for current parser or subparser. If you use `action` argument to process
      different transactions, pass a `Callback` class inheritted from 
      `BaseHandler` is not a bad idea.
    - provide `run` method to run program by calling the given callback.
    """

    def __init__(self, formatter_class=SmartFormatter, **kwargs):
        super().__init__(formatter_class=formatter_class, **kwargs)
        self.__subparsers = None

    @property
    def subparsers(self):
        if self.__subparsers is None:
            self.__subparsers = self.add_subparsers()
        return self.__subparsers

    def set_callback(self, callback: Callable = None, Callback: BaseHandler = None):
        """
        set callback function or Callback class for current parser or subparser.

        Args:
            - `callback` a function to run main program
            - `Callback` a class to run different actions

        """
        levels = 'DEBUG|INFO|WARNING|ERROR|CRITICAL'
        self.add_argument('-l', '--log-level', choices=levels.split('|'), default='INFO', metavar=levels, help="set logging level")

        if callback is not None:
            self.set_defaults(callback=callback, Callback=None)
        elif Callback is not None:
            self.set_defaults(callback=None, Callback=Callback)
        else:
            raise Exception('`Callback` and `callback` cannot be both `None`.')

    def run(self, args: Namespace = None):
        """
        Run callback function.

        Args:
            - `args`: a `Namespace` object for parsed arguments.
                Use default parsed args if `None`. 
        """
        args = self.parse_args() if args is None else args
        log_level: str = args.log_level
        logging.getLogger().setLevel(log_level)

        if args.callback is not None:
            callback: Callable = args.callback
            callback(args)
        else:
            Callback: BaseHandler = args.Callback
            Callback.run(args)

    def get_subparser(self, *args, **kwargs):
        return self.subparsers.add_parser(*args, **kwargs)
